package org.dbfit.greenpepper;

import static com.greenpepper.annotation.Annotations.exception;
import static com.greenpepper.annotation.Annotations.wrong;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import org.dbfit.greenpepper.util.DbAccessorCellHelper;
import org.dbfit.greenpepper.util.GreenPepperTestHost;
import org.dbfit.greenpepper.util.Table;

import com.greenpepper.Example;
import com.greenpepper.ExecutionContext;
import com.greenpepper.GreenPepper;
import com.greenpepper.Interpreter;
import com.greenpepper.Specification;
import com.greenpepper.Statistics;
import com.greenpepper.interpreter.HeaderForm;
import com.greenpepper.interpreter.column.Column;
import com.greenpepper.reflect.Fixture;

import dbfit.util.DbParameterAccessor;
import dbfit.util.NameNormaliser;

/** this interpreter will execute a given statement for 
 * each of the examples in the specification, first populating
 * all inputs, then running the statement, finally checking all the outputs
 * and finally clearing all statement parameters. 
 */
public class InsertIntoInterpreter implements Interpreter{
    private final Table targetTable;    
    protected Statistics stats;
    private DbParameterAccessor[] accessors;
    private PreparedStatement statement;
    private Column[] columns;
    public InsertIntoInterpreter( Fixture fixture )
    {
        if (fixture.getTarget() instanceof Table){
        	this.targetTable=(Table) fixture.getTarget();
        }
        else
        	throw new UnsupportedOperationException("This interpreter does not support "+fixture);
    }
	public PreparedStatement buildPreparedStatement(DbParameterAccessor[] accessors) throws SQLException {
		PreparedStatement statement= targetTable.getDbEnvironment().buildInsertPreparedStatement(
				targetTable.getTableName(), accessors);
		for (int i = 0; i < accessors.length; i++) {
			accessors[i].bindTo(statement, i + 1);
		}
		return statement;
	}
	
    public void interpret( Specification specification )
    {
        stats = new Statistics();
        Example table = specification.nextExample();
        accessors = parseHeaders( table );
        GreenPepperTestHost.getInstance().copyToExecutionContext(specification);
        try{
            columns=parseColumnHeaders(table, accessors, specification);
        	statement=buildPreparedStatement(accessors);        
        	for (Example row = table.at( 0, 2 ); row != null; row = row.nextSibling())
	        {
	            runRow( row );
	        }
        }
        catch (Exception e){
        	table.annotate(exception(e));
        	stats.exception();
        }
        specification.exampleDone( stats );
        GreenPepperTestHost.getInstance().copyFromExecutionContext(specification);        
    }
 
    private DbParameterAccessor[] parseHeaders( Example table ){
        Example headers = table.at( 0, 1, 0 );
        if (headers == null) return new DbParameterAccessor[0];

        DbParameterAccessor[] columns = new DbParameterAccessor[headers.remainings()];
        for (int i = 0; i < headers.remainings(); i++)
        {
            columns[i] = parseColumn( headers.at( i ) );
        }
        return columns;
    }
    private Column[] parseColumnHeaders(Example table, DbParameterAccessor[] accessors, ExecutionContext specification) throws Exception{
        Example headers = table.at( 0, 1, 0 );
        if (headers == null) return new Column[0];
        Column[] columns = new Column[headers.remainings()];
        for (int i = 0; i < headers.remainings(); i++)
        {

        	columns[i]=DbAccessorCellHelper.getColumn(headers.at(i).getContent(),accessors[i]);
        	columns[i].bindTo(specification);
        }
        return columns;

    }
    private DbParameterAccessor parseColumn( Example header )
    {
        try
        {
        	String headerContent=header.getContent();
        	DbParameterAccessor accessor=targetTable.getAllAccessors().get(NameNormaliser.normaliseName(headerContent));
        	if (accessor==null) { header.annotate(wrong()); return null;}
        	HeaderForm hf=HeaderForm.parse(headerContent);
        	if ((!hf.isGiven()) && accessor.getDirection()==DbParameterAccessor.INPUT){
        		accessor=targetTable.getDbEnvironment().createAutogeneratedPrimaryKeyAccessor(accessor);
        	}
        	return accessor;
        }
        catch (Exception e)
        {
            header.annotate( exception( e ) );
            stats.exception();
            return null;
        }
    }


	private void runRow(Example row)  throws Exception{
		statement.clearParameters();
		if (!row.hasChild()) return;
		Example cells = row.firstChild();
		for(int column=0; column<accessors.length; column++){
			if (accessors[column].getDirection()==DbParameterAccessor.INPUT) {
				columns[column].doCell(cells.at( column ));
			}
		} 
		statement.execute();
		for(int column=0; column<accessors.length; column++){
			if (accessors[column].getDirection()==DbParameterAccessor.OUTPUT||
					accessors[column].getDirection()==DbParameterAccessor.RETURN_VALUE) {
				columns[column].doCell(cells.at( column ));
			}
		}							
	}

}
